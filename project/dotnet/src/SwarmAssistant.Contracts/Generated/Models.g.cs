// <auto-generated />
//
// To parse this JSON data, add NuGet 'Newtonsoft.Json' then do one of these:
//
//    using SwarmAssistant.Contracts.Generated;
//
//    var a2ATaskSubmitRequest = A2ATaskSubmitRequest.FromJson(jsonString);
//    var a2ATaskSubmitResponse = A2ATaskSubmitResponse.FromJson(jsonString);
//    var agentCard = AgentCard.FromJson(jsonString);
//    var agentRegistryEntry = AgentRegistryEntry.FromJson(jsonString);
//    var errorEnvelope = ErrorEnvelope.FromJson(jsonString);
//    var healthResponse = HealthResponse.FromJson(jsonString);
//    var memoryTaskListResponse = MemoryTaskListResponse.FromJson(jsonString);
//    var taskExecutionEvent = TaskExecutionEvent.FromJson(jsonString);
//    var taskExecutionEventFeed = TaskExecutionEventFeed.FromJson(jsonString);
//    var taskSnapshot = TaskSnapshot.FromJson(jsonString);
//    var taskState = TaskState.FromJson(jsonString);
//    var taskSummary = TaskSummary.FromJson(jsonString);
//    var uiActionRequest = UiActionRequest.FromJson(jsonString);
//    var uiActionResponse = UiActionResponse.FromJson(jsonString);
//    var uiEventEnvelope = UiEventEnvelope.FromJson(jsonString);

namespace SwarmAssistant.Contracts.Generated
{
    using System;
    using System.Collections.Generic;

    using System.Globalization;
    using Newtonsoft.Json;
    using Newtonsoft.Json.Converters;

    /// <summary>
    /// Payload for submitting a new agent-to-agent task.
    /// </summary>
    public partial class A2ATaskSubmitRequest
    {
        /// <summary>
        /// Full task description.
        /// </summary>
        [JsonProperty("description")]
        public string Description { get; set; }

        /// <summary>
        /// Arbitrary caller-supplied metadata attached to the task.
        /// </summary>
        [JsonProperty("metadata")]
        public Dictionary<string, object> Metadata { get; set; }

        /// <summary>
        /// Optional run identifier to associate this task with an existing run.
        /// </summary>
        [JsonProperty("runId")]
        public string? RunId { get; set; }

        /// <summary>
        /// Optional caller-supplied task identifier. Auto-generated if omitted.
        /// </summary>
        [JsonProperty("taskId")]
        public string TaskId { get; set; }

        /// <summary>
        /// Short human-readable task title.
        /// </summary>
        [JsonProperty("title")]
        public string Title { get; set; }
    }

    /// <summary>
    /// Acknowledgement returned after an A2A task is accepted.
    /// </summary>
    public partial class A2ATaskSubmitResponse
    {
        /// <summary>
        /// Always `accepted` on a successful submission.
        /// </summary>
        [JsonProperty("status")]
        public Status Status { get; set; }

        /// <summary>
        /// Relative URL to poll for task status.
        /// </summary>
        [JsonProperty("statusUrl")]
        public string StatusUrl { get; set; }

        /// <summary>
        /// Assigned task identifier.
        /// </summary>
        [JsonProperty("taskId")]
        public string TaskId { get; set; }
    }

    /// <summary>
    /// A2A agent capability descriptor served at `/.well-known/agent-card.json`.
    /// </summary>
    public partial class AgentCard
    {
        /// <summary>
        /// List of capability tags advertised by this agent.
        /// </summary>
        [JsonProperty("capabilities")]
        public List<string> Capabilities { get; set; }

        [JsonProperty("description")]
        public string Description { get; set; }

        /// <summary>
        /// Named endpoint URLs exposed by this agent.
        /// </summary>
        [JsonProperty("endpoints")]
        public Dictionary<string, string> Endpoints { get; set; }

        [JsonProperty("name")]
        public string Name { get; set; }

        /// <summary>
        /// Protocol identifier (e.g. `a2a`).
        /// </summary>
        [JsonProperty("protocol")]
        public string Protocol { get; set; }

        /// <summary>
        /// Isolation level: 0=BareCli, 1=OsSandboxed, 2=Container
        /// </summary>
        [JsonProperty("sandboxLevel", NullValueHandling = NullValueHandling.Ignore)]
        public long? SandboxLevel { get; set; }

        [JsonProperty("sandboxRequirements")]
        public SandboxRequirements SandboxRequirements { get; set; }

        [JsonProperty("version")]
        public string Version { get; set; }
    }

    public partial class SandboxRequirements
    {
        [JsonProperty("needsGpuAccess", NullValueHandling = NullValueHandling.Ignore)]
        public bool? NeedsGpuAccess { get; set; }

        [JsonProperty("needsKeychain", NullValueHandling = NullValueHandling.Ignore)]
        public bool? NeedsKeychain { get; set; }

        [JsonProperty("needsNetwork", NullValueHandling = NullValueHandling.Ignore)]
        public List<string> NeedsNetwork { get; set; }

        [JsonProperty("needsOAuth", NullValueHandling = NullValueHandling.Ignore)]
        public bool? NeedsOAuth { get; set; }
    }

    /// <summary>
    /// Runtime registry entry describing a discovered or registered agent instance.
    /// </summary>
    public partial class AgentRegistryEntry
    {
        /// <summary>
        /// Unique identifier for this agent instance.
        /// </summary>
        [JsonProperty("agentId")]
        public string AgentId { get; set; }

        /// <summary>
        /// Token budget tracking for the agent.
        /// </summary>
        [JsonProperty("budget")]
        public Budget Budget { get; set; }

        /// <summary>
        /// List of capability tags advertised by this agent.
        /// </summary>
        [JsonProperty("capabilities")]
        public List<string> Capabilities { get; set; }

        /// <summary>
        /// Circuit breaker state (e.g., 'closed', 'open', 'half-open').
        /// </summary>
        [JsonProperty("circuitBreakerState")]
        public string CircuitBreakerState { get; set; }

        /// <summary>
        /// Number of consecutive health check failures.
        /// </summary>
        [JsonProperty("consecutiveFailures")]
        public long ConsecutiveFailures { get; set; }

        /// <summary>
        /// Base URL for communicating with this agent instance.
        /// </summary>
        [JsonProperty("endpointUrl")]
        public string EndpointUrl { get; set; }

        /// <summary>
        /// ISO 8601 timestamp of the last successful heartbeat.
        /// </summary>
        [JsonProperty("lastHeartbeat")]
        public DateTimeOffset LastHeartbeat { get; set; }

        /// <summary>
        /// Provider configuration for the agent runtime.
        /// </summary>
        [JsonProperty("provider")]
        public Provider Provider { get; set; }

        /// <summary>
        /// ISO 8601 timestamp when the agent was registered.
        /// </summary>
        [JsonProperty("registeredAt")]
        public DateTimeOffset RegisteredAt { get; set; }

        /// <summary>
        /// Isolation level: 0=BareCli, 1=OsSandboxed, 2=Container
        /// </summary>
        [JsonProperty("sandboxLevel")]
        public long SandboxLevel { get; set; }

        /// <summary>
        /// Current operational status of the agent.
        /// </summary>
        [JsonProperty("status")]
        public string Status { get; set; }
    }

    public partial class Budget
    {
        /// <summary>
        /// Fraction of budget remaining (0.0 to 1.0).
        /// </summary>
        [JsonProperty("remainingFraction", NullValueHandling = NullValueHandling.Ignore)]
        public double? RemainingFraction { get; set; }

        /// <summary>
        /// Total token allocation.
        /// </summary>
        [JsonProperty("totalTokens", NullValueHandling = NullValueHandling.Ignore)]
        public long? TotalTokens { get; set; }

        /// <summary>
        /// Budget type identifier.
        /// </summary>
        [JsonProperty("type", NullValueHandling = NullValueHandling.Ignore)]
        public string Type { get; set; }

        /// <summary>
        /// Tokens consumed so far.
        /// </summary>
        [JsonProperty("usedTokens", NullValueHandling = NullValueHandling.Ignore)]
        public long? UsedTokens { get; set; }
    }

    public partial class Provider
    {
        /// <summary>
        /// Adapter type for agent execution.
        /// </summary>
        [JsonProperty("adapter", NullValueHandling = NullValueHandling.Ignore)]
        public string Adapter { get; set; }

        /// <summary>
        /// Service plan or tier.
        /// </summary>
        [JsonProperty("plan", NullValueHandling = NullValueHandling.Ignore)]
        public string Plan { get; set; }

        /// <summary>
        /// Provider type identifier.
        /// </summary>
        [JsonProperty("type", NullValueHandling = NullValueHandling.Ignore)]
        public string Type { get; set; }
    }

    /// <summary>
    /// Standardised error response body returned on 4xx/5xx responses.
    /// </summary>
    public partial class ErrorEnvelope
    {
        /// <summary>
        /// Action identifier associated with the error, when applicable.
        /// </summary>
        [JsonProperty("actionId")]
        public string ActionId { get; set; }

        /// <summary>
        /// Human-readable error message.
        /// </summary>
        [JsonProperty("error")]
        public string Error { get; set; }

        /// <summary>
        /// Machine-readable reason code.
        /// </summary>
        [JsonProperty("reasonCode")]
        public string ReasonCode { get; set; }

        /// <summary>
        /// Task identifier associated with the error, when applicable.
        /// </summary>
        [JsonProperty("taskId")]
        public string TaskId { get; set; }
    }

    /// <summary>
    /// Response body for the `/healthz` health check endpoint.
    /// </summary>
    public partial class HealthResponse
    {
        /// <summary>
        /// Always `true` when the runtime is reachable.
        /// </summary>
        [JsonProperty("ok")]
        public bool Ok { get; set; }
    }

    /// <summary>
    /// Response body for `GET /memory/tasks` containing a list of task snapshots.
    /// </summary>
    public partial class MemoryTaskListResponse
    {
        [JsonProperty("items")]
        public List<TaskSnapshot> Items { get; set; }

        /// <summary>
        /// Backend that served the results (`arcadedb` or `registry`).
        /// </summary>
        [JsonProperty("source")]
        public Source Source { get; set; }
    }

    /// <summary>
    /// Full snapshot of a swarm task including all role outputs.
    /// </summary>
    public partial class TaskSnapshot
    {
        /// <summary>
        /// Output produced by the builder role.
        /// </summary>
        [JsonProperty("buildOutput")]
        public string BuildOutput { get; set; }

        /// <summary>
        /// Identifiers of child sub-tasks spawned by this task.
        /// </summary>
        [JsonProperty("childTaskIds")]
        public List<string> ChildTaskIds { get; set; }

        /// <summary>
        /// ISO 8601 timestamp when the task was created.
        /// </summary>
        [JsonProperty("createdAt")]
        public DateTimeOffset CreatedAt { get; set; }

        /// <summary>
        /// Full task description.
        /// </summary>
        [JsonProperty("description")]
        public string Description { get; set; }

        /// <summary>
        /// Error message when the task has failed.
        /// </summary>
        [JsonProperty("error")]
        public string Error { get; set; }

        /// <summary>
        /// Identifier of the parent task, if this is a sub-task.
        /// </summary>
        [JsonProperty("parentTaskId")]
        public string ParentTaskId { get; set; }

        /// <summary>
        /// Output produced by the planner role.
        /// </summary>
        [JsonProperty("planningOutput")]
        public string PlanningOutput { get; set; }

        /// <summary>
        /// Output produced by the reviewer role.
        /// </summary>
        [JsonProperty("reviewOutput")]
        public string ReviewOutput { get; set; }

        /// <summary>
        /// Run identifier this task belongs to.
        /// </summary>
        [JsonProperty("runId")]
        public string? RunId { get; set; }

        [JsonProperty("status")]
        public TaskStateEnum Status { get; set; }

        /// <summary>
        /// Final summary when the task is completed.
        /// </summary>
        [JsonProperty("summary")]
        public string Summary { get; set; }

        /// <summary>
        /// Unique task identifier.
        /// </summary>
        [JsonProperty("taskId")]
        public string TaskId { get; set; }

        /// <summary>
        /// Short human-readable task title.
        /// </summary>
        [JsonProperty("title")]
        public string Title { get; set; }

        /// <summary>
        /// ISO 8601 timestamp of the last status update.
        /// </summary>
        [JsonProperty("updatedAt")]
        public DateTimeOffset UpdatedAt { get; set; }
    }

    /// <summary>
    /// Paginated feed of task execution events returned by replay endpoints.
    /// </summary>
    public partial class TaskExecutionEventFeed
    {
        /// <summary>
        /// Ordered list of events (ascending by sequence).
        /// </summary>
        [JsonProperty("items")]
        public List<TaskExecutionEvent> Items { get; set; }

        /// <summary>
        /// Sequence number of the last returned event; pass as `cursor` in the next request to
        /// continue pagination. `null` when no events were returned.
        /// </summary>
        [JsonProperty("nextCursor")]
        public long? NextCursor { get; set; }

        /// <summary>
        /// Run identifier, present for run-scoped feeds.
        /// </summary>
        [JsonProperty("runId")]
        public string? RunId { get; set; }

        /// <summary>
        /// Task identifier, present for task-scoped feeds.
        /// </summary>
        [JsonProperty("taskId")]
        public string? TaskId { get; set; }
    }

    /// <summary>
    /// An immutable, append-only event recorded during task execution. Used for audit trails and
    /// replay feeds.
    /// </summary>
    public partial class TaskExecutionEvent
    {
        /// <summary>
        /// Unique event identifier.
        /// </summary>
        [JsonProperty("eventId")]
        public string EventId { get; set; }

        /// <summary>
        /// Event type discriminator (e.g. `task.started`, `role.completed`).
        /// </summary>
        [JsonProperty("eventType")]
        public string EventType { get; set; }

        /// <summary>
        /// ISO 8601 timestamp when the event occurred.
        /// </summary>
        [JsonProperty("occurredAt")]
        public DateTimeOffset OccurredAt { get; set; }

        /// <summary>
        /// JSON-encoded event payload, when present.
        /// </summary>
        [JsonProperty("payload")]
        public string? Payload { get; set; }

        /// <summary>
        /// Identifier of the swarm run this event belongs to.
        /// </summary>
        [JsonProperty("runId")]
        public string RunId { get; set; }

        /// <summary>
        /// Monotonically increasing sequence number scoped to the run.
        /// </summary>
        [JsonProperty("runSequence")]
        public long RunSequence { get; set; }

        /// <summary>
        /// Identifier of the task this event belongs to.
        /// </summary>
        [JsonProperty("taskId")]
        public string TaskId { get; set; }

        /// <summary>
        /// Monotonically increasing sequence number scoped to the task.
        /// </summary>
        [JsonProperty("taskSequence")]
        public long TaskSequence { get; set; }
    }

    /// <summary>
    /// Lightweight task representation used in list responses.
    /// </summary>
    public partial class TaskSummary
    {
        [JsonProperty("error")]
        public string Error { get; set; }

        [JsonProperty("status")]
        public TaskStateEnum Status { get; set; }

        [JsonProperty("taskId")]
        public string TaskId { get; set; }

        [JsonProperty("title")]
        public string Title { get; set; }

        [JsonProperty("updatedAt")]
        public DateTimeOffset UpdatedAt { get; set; }
    }

    /// <summary>
    /// Action submitted by a UI client via the AG-UI actions gateway.
    /// </summary>
    public partial class UiActionRequest
    {
        /// <summary>
        /// Action to perform. Supported values: `request_snapshot`, `refresh_surface`,
        /// `submit_task`, `load_memory`, `approve_review`, `reject_review`, `request_rework`,
        /// `pause_task`, `resume_task`, `approve_task`, `cancel_task`, `set_subtask_depth`.
        /// </summary>
        [JsonProperty("actionId")]
        public ActionId ActionId { get; set; }

        /// <summary>
        /// Action-specific payload. For `submit_task`, provide `title` and optional `description` /
        /// `taskId` keys. For `set_subtask_depth`, provide `depth` (integer). For `load_memory`,
        /// provide optional `limit` (integer).
        /// </summary>
        [JsonProperty("payload")]
        public Dictionary<string, object> Payload { get; set; }

        /// <summary>
        /// Target task identifier, required for task-scoped actions.
        /// </summary>
        [JsonProperty("taskId")]
        public string TaskId { get; set; }
    }

    /// <summary>
    /// Acknowledgement returned after a UI action is enqueued.
    /// </summary>
    public partial class UiActionResponse
    {
        /// <summary>
        /// Echoes the submitted `actionId`.
        /// </summary>
        [JsonProperty("actionId")]
        public string ActionId { get; set; }

        /// <summary>
        /// Machine-readable outcome code (e.g. `accepted`).
        /// </summary>
        [JsonProperty("reasonCode")]
        public string ReasonCode { get; set; }

        /// <summary>
        /// Target task identifier, when applicable.
        /// </summary>
        [JsonProperty("taskId")]
        public string TaskId { get; set; }
    }

    /// <summary>
    /// A single event emitted by the AG-UI event stream.
    /// </summary>
    public partial class UiEventEnvelope
    {
        /// <summary>
        /// ISO 8601 timestamp when the event was emitted.
        /// </summary>
        [JsonProperty("at")]
        public DateTimeOffset At { get; set; }

        /// <summary>
        /// Event-specific payload; shape varies by `type`.
        /// </summary>
        [JsonProperty("payload")]
        public Dictionary<string, object> Payload { get; set; }

        /// <summary>
        /// Monotonically increasing sequence number.
        /// </summary>
        [JsonProperty("sequence")]
        public long Sequence { get; set; }

        /// <summary>
        /// Associated task identifier, when applicable.
        /// </summary>
        [JsonProperty("taskId")]
        public string TaskId { get; set; }

        /// <summary>
        /// Event type discriminator (e.g. `agui.task.snapshot`, `agui.task.status`,
        /// `agui.graph.node`, `agui.graph.edge`).
        /// </summary>
        [JsonProperty("type")]
        public string Type { get; set; }
    }

    /// <summary>
    /// Always `accepted` on a successful submission.
    /// </summary>
    public enum Status { Accepted };

    /// <summary>
    /// Lifecycle state of a swarm task.
    /// </summary>
    public enum TaskStateEnum { Blocked, Building, Done, Planning, Queued, Reviewing };

    /// <summary>
    /// Backend that served the results (`arcadedb` or `registry`).
    /// </summary>
    public enum Source { Arcadedb, Registry };

    /// <summary>
    /// Action to perform. Supported values: `request_snapshot`, `refresh_surface`,
    /// `submit_task`, `load_memory`, `approve_review`, `reject_review`, `request_rework`,
    /// `pause_task`, `resume_task`, `approve_task`, `cancel_task`, `set_subtask_depth`.
    /// </summary>
    public enum ActionId { ApproveReview, ApproveTask, CancelTask, LoadMemory, PauseTask, RefreshSurface, RejectReview, RequestRework, RequestSnapshot, ResumeTask, SetSubtaskDepth, SubmitTask };

    public partial class A2ATaskSubmitRequest
    {
        public static A2ATaskSubmitRequest FromJson(string json) => JsonConvert.DeserializeObject<A2ATaskSubmitRequest>(json, SwarmAssistant.Contracts.Generated.Converter.Settings);
    }

    public partial class A2ATaskSubmitResponse
    {
        public static A2ATaskSubmitResponse FromJson(string json) => JsonConvert.DeserializeObject<A2ATaskSubmitResponse>(json, SwarmAssistant.Contracts.Generated.Converter.Settings);
    }

    public partial class AgentCard
    {
        public static AgentCard FromJson(string json) => JsonConvert.DeserializeObject<AgentCard>(json, SwarmAssistant.Contracts.Generated.Converter.Settings);
    }

    public partial class AgentRegistryEntry
    {
        public static AgentRegistryEntry FromJson(string json) => JsonConvert.DeserializeObject<AgentRegistryEntry>(json, SwarmAssistant.Contracts.Generated.Converter.Settings);
    }

    public partial class ErrorEnvelope
    {
        public static ErrorEnvelope FromJson(string json) => JsonConvert.DeserializeObject<ErrorEnvelope>(json, SwarmAssistant.Contracts.Generated.Converter.Settings);
    }

    public partial class HealthResponse
    {
        public static HealthResponse FromJson(string json) => JsonConvert.DeserializeObject<HealthResponse>(json, SwarmAssistant.Contracts.Generated.Converter.Settings);
    }

    public partial class MemoryTaskListResponse
    {
        public static MemoryTaskListResponse FromJson(string json) => JsonConvert.DeserializeObject<MemoryTaskListResponse>(json, SwarmAssistant.Contracts.Generated.Converter.Settings);
    }

    public partial class TaskExecutionEvent
    {
        public static TaskExecutionEvent FromJson(string json) => JsonConvert.DeserializeObject<TaskExecutionEvent>(json, SwarmAssistant.Contracts.Generated.Converter.Settings);
    }

    public partial class TaskExecutionEventFeed
    {
        public static TaskExecutionEventFeed FromJson(string json) => JsonConvert.DeserializeObject<TaskExecutionEventFeed>(json, SwarmAssistant.Contracts.Generated.Converter.Settings);
    }

    public partial class TaskSnapshot
    {
        public static TaskSnapshot FromJson(string json) => JsonConvert.DeserializeObject<TaskSnapshot>(json, SwarmAssistant.Contracts.Generated.Converter.Settings);
    }

    public class TaskState
    {
        public static TaskStateEnum FromJson(string json) => JsonConvert.DeserializeObject<TaskStateEnum>(json, SwarmAssistant.Contracts.Generated.Converter.Settings);
    }

    public partial class TaskSummary
    {
        public static TaskSummary FromJson(string json) => JsonConvert.DeserializeObject<TaskSummary>(json, SwarmAssistant.Contracts.Generated.Converter.Settings);
    }

    public partial class UiActionRequest
    {
        public static UiActionRequest FromJson(string json) => JsonConvert.DeserializeObject<UiActionRequest>(json, SwarmAssistant.Contracts.Generated.Converter.Settings);
    }

    public partial class UiActionResponse
    {
        public static UiActionResponse FromJson(string json) => JsonConvert.DeserializeObject<UiActionResponse>(json, SwarmAssistant.Contracts.Generated.Converter.Settings);
    }

    public partial class UiEventEnvelope
    {
        public static UiEventEnvelope FromJson(string json) => JsonConvert.DeserializeObject<UiEventEnvelope>(json, SwarmAssistant.Contracts.Generated.Converter.Settings);
    }

    public static class Serialize
    {
        public static string ToJson(this A2ATaskSubmitRequest self) => JsonConvert.SerializeObject(self, SwarmAssistant.Contracts.Generated.Converter.Settings);
        public static string ToJson(this A2ATaskSubmitResponse self) => JsonConvert.SerializeObject(self, SwarmAssistant.Contracts.Generated.Converter.Settings);
        public static string ToJson(this AgentCard self) => JsonConvert.SerializeObject(self, SwarmAssistant.Contracts.Generated.Converter.Settings);
        public static string ToJson(this AgentRegistryEntry self) => JsonConvert.SerializeObject(self, SwarmAssistant.Contracts.Generated.Converter.Settings);
        public static string ToJson(this ErrorEnvelope self) => JsonConvert.SerializeObject(self, SwarmAssistant.Contracts.Generated.Converter.Settings);
        public static string ToJson(this HealthResponse self) => JsonConvert.SerializeObject(self, SwarmAssistant.Contracts.Generated.Converter.Settings);
        public static string ToJson(this MemoryTaskListResponse self) => JsonConvert.SerializeObject(self, SwarmAssistant.Contracts.Generated.Converter.Settings);
        public static string ToJson(this TaskExecutionEvent self) => JsonConvert.SerializeObject(self, SwarmAssistant.Contracts.Generated.Converter.Settings);
        public static string ToJson(this TaskExecutionEventFeed self) => JsonConvert.SerializeObject(self, SwarmAssistant.Contracts.Generated.Converter.Settings);
        public static string ToJson(this TaskSnapshot self) => JsonConvert.SerializeObject(self, SwarmAssistant.Contracts.Generated.Converter.Settings);
        public static string ToJson(this TaskStateEnum self) => JsonConvert.SerializeObject(self, SwarmAssistant.Contracts.Generated.Converter.Settings);
        public static string ToJson(this TaskSummary self) => JsonConvert.SerializeObject(self, SwarmAssistant.Contracts.Generated.Converter.Settings);
        public static string ToJson(this UiActionRequest self) => JsonConvert.SerializeObject(self, SwarmAssistant.Contracts.Generated.Converter.Settings);
        public static string ToJson(this UiActionResponse self) => JsonConvert.SerializeObject(self, SwarmAssistant.Contracts.Generated.Converter.Settings);
        public static string ToJson(this UiEventEnvelope self) => JsonConvert.SerializeObject(self, SwarmAssistant.Contracts.Generated.Converter.Settings);
    }

    internal static class Converter
    {
        public static readonly JsonSerializerSettings Settings = new JsonSerializerSettings
        {
            MetadataPropertyHandling = MetadataPropertyHandling.Ignore,
            DateParseHandling = DateParseHandling.None,
            Converters =
            {
                StatusConverter.Singleton,
                TaskStateEnumConverter.Singleton,
                SourceConverter.Singleton,
                ActionIdConverter.Singleton,
                new IsoDateTimeConverter { DateTimeStyles = DateTimeStyles.AssumeUniversal }
            },
        };
    }

    internal class StatusConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Status) || t == typeof(Status?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            if (value == "accepted")
            {
                return Status.Accepted;
            }
            throw new Exception("Cannot unmarshal type Status");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Status)untypedValue;
            if (value == Status.Accepted)
            {
                serializer.Serialize(writer, "accepted");
                return;
            }
            throw new Exception("Cannot marshal type Status");
        }

        public static readonly StatusConverter Singleton = new StatusConverter();
    }

    internal class TaskStateEnumConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(TaskStateEnum) || t == typeof(TaskStateEnum?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "blocked":
                    return TaskStateEnum.Blocked;
                case "building":
                    return TaskStateEnum.Building;
                case "done":
                    return TaskStateEnum.Done;
                case "planning":
                    return TaskStateEnum.Planning;
                case "queued":
                    return TaskStateEnum.Queued;
                case "reviewing":
                    return TaskStateEnum.Reviewing;
            }
            throw new Exception("Cannot unmarshal type TaskStateEnum");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (TaskStateEnum)untypedValue;
            switch (value)
            {
                case TaskStateEnum.Blocked:
                    serializer.Serialize(writer, "blocked");
                    return;
                case TaskStateEnum.Building:
                    serializer.Serialize(writer, "building");
                    return;
                case TaskStateEnum.Done:
                    serializer.Serialize(writer, "done");
                    return;
                case TaskStateEnum.Planning:
                    serializer.Serialize(writer, "planning");
                    return;
                case TaskStateEnum.Queued:
                    serializer.Serialize(writer, "queued");
                    return;
                case TaskStateEnum.Reviewing:
                    serializer.Serialize(writer, "reviewing");
                    return;
            }
            throw new Exception("Cannot marshal type TaskStateEnum");
        }

        public static readonly TaskStateEnumConverter Singleton = new TaskStateEnumConverter();
    }

    internal class SourceConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Source) || t == typeof(Source?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "arcadedb":
                    return Source.Arcadedb;
                case "registry":
                    return Source.Registry;
            }
            throw new Exception("Cannot unmarshal type Source");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Source)untypedValue;
            switch (value)
            {
                case Source.Arcadedb:
                    serializer.Serialize(writer, "arcadedb");
                    return;
                case Source.Registry:
                    serializer.Serialize(writer, "registry");
                    return;
            }
            throw new Exception("Cannot marshal type Source");
        }

        public static readonly SourceConverter Singleton = new SourceConverter();
    }

    internal class ActionIdConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(ActionId) || t == typeof(ActionId?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "approve_review":
                    return ActionId.ApproveReview;
                case "approve_task":
                    return ActionId.ApproveTask;
                case "cancel_task":
                    return ActionId.CancelTask;
                case "load_memory":
                    return ActionId.LoadMemory;
                case "pause_task":
                    return ActionId.PauseTask;
                case "refresh_surface":
                    return ActionId.RefreshSurface;
                case "reject_review":
                    return ActionId.RejectReview;
                case "request_rework":
                    return ActionId.RequestRework;
                case "request_snapshot":
                    return ActionId.RequestSnapshot;
                case "resume_task":
                    return ActionId.ResumeTask;
                case "set_subtask_depth":
                    return ActionId.SetSubtaskDepth;
                case "submit_task":
                    return ActionId.SubmitTask;
            }
            throw new Exception("Cannot unmarshal type ActionId");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (ActionId)untypedValue;
            switch (value)
            {
                case ActionId.ApproveReview:
                    serializer.Serialize(writer, "approve_review");
                    return;
                case ActionId.ApproveTask:
                    serializer.Serialize(writer, "approve_task");
                    return;
                case ActionId.CancelTask:
                    serializer.Serialize(writer, "cancel_task");
                    return;
                case ActionId.LoadMemory:
                    serializer.Serialize(writer, "load_memory");
                    return;
                case ActionId.PauseTask:
                    serializer.Serialize(writer, "pause_task");
                    return;
                case ActionId.RefreshSurface:
                    serializer.Serialize(writer, "refresh_surface");
                    return;
                case ActionId.RejectReview:
                    serializer.Serialize(writer, "reject_review");
                    return;
                case ActionId.RequestRework:
                    serializer.Serialize(writer, "request_rework");
                    return;
                case ActionId.RequestSnapshot:
                    serializer.Serialize(writer, "request_snapshot");
                    return;
                case ActionId.ResumeTask:
                    serializer.Serialize(writer, "resume_task");
                    return;
                case ActionId.SetSubtaskDepth:
                    serializer.Serialize(writer, "set_subtask_depth");
                    return;
                case ActionId.SubmitTask:
                    serializer.Serialize(writer, "submit_task");
                    return;
            }
            throw new Exception("Cannot marshal type ActionId");
        }

        public static readonly ActionIdConverter Singleton = new ActionIdConverter();
    }
}
